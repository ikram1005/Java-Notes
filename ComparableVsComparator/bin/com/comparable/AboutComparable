//	The `Comparable` interface in Java is used to define a natural ordering
//	of objects. By implementing the `Comparable` interface, a class can specify
//	how its instances should be compared to each other. The `Comparable`
//	interface contains a single method, `compareTo()`, which compares
//	the current object with another object and returns an integer value
//	indicating the order.
//
//	Advantages of using `Comparable`:
//	1. Natural ordering: By implementing `Comparable`, you define a natural
       ordering for objects of your class. This allows you to easily sort and
       organize collections of objects based on their natural order without
       requiring any external comparators.
//
//	2. Simplicity: The `Comparable` interface provides a straightforward way to 
       define object comparisons. Once implemented, you can directly use methods
       like `Collections.sort()` to sort objects or use them in data structures
       like sorted sets and sorted maps.
//
//	3. Enhanced API compatibility: Many built-in Java classes and APIs rely on
       the `Comparable` interface. Implementing `Comparable` enables your class
       to seamlessly integrate with these APIs, making it easier to work with
       existing Java libraries.
//
//	Disadvantages/limitations of using `Comparable`:
//	1. Single sorting order: The `Comparable` interface allows you to define
       a single way of comparing objects. If you need different sorting orders
       or want to compare objects based on multiple criteria, you may need to
       implement a separate comparator using the `Comparator` interface.
//
//	2. Modifying existing classes: Implementing `Comparable` requires modifying
       the class for which you want to define the natural ordering. If you don't
       have control over the class or if modifying the class is not desirable,
       you cannot implement `Comparable` for that class.
//
//	3. Lack of flexibility: With `Comparable`, the comparison logic is fixed
       within the class implementation. If you need to change the sorting order 
       or comparison logic in different scenarios, you have to modify the class 
       itself. In contrast, using a separate `Comparator` allows more flexibility 
       in defining different comparison rules without modifying the class.
//
//	In summary, `Comparable` provides a convenient way to define a natural 
    ordering for objects, making it easier to sort and organize them. However, 
    it has limitations when it comes to flexibility and multiple sorting orders, 
    which can be overcome by using the `Comparator` interface.
//	
